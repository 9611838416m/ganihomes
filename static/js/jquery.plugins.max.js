eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('(5($){$.1l.1m=5(m){4 n={u:\'1n\',Z:\'1o\',C:\'1p\',10:\'1q\',11:9,12:\'\',13:\'\',Q:9,v:\'1r\',14:\'1s\',15:6,D:\'1t\',16:\'1u\',17:6,L:6,R:1v,S:6,T:1w,x:6,E:6,y:\'1x\'};4 m=$.1y(n,m);U.1z(5(){4 f=$(U);4 s=$("o",f).1A;4 w=$("o",f).M();4 h=$("o",f).18();4 g=9;f.M(w);f.18(h);f.r("1B","1C");4 j=s-1;4 t=0;$("7",f).r(\'M\',s*w);3(m.x){$("7",f).1D($("7 o:V-19",f).1a().r("W-N","-"+w+"1E"));$("7",f).1F($("7 o:1G-19(2)",f).1a());$("7",f).r(\'M\',(s+1)*w)};3(!m.L)$("o",f).r(\'1H\',\'N\');3(m.11){4 k=m.12;3(m.E){k+=\'<1b z="\'+m.y+\'"></1b>\'}A{3(m.15)k+=\'<q z="\'+m.v+\'"><a F=\\"G:H(0);\\">\'+m.14+\'</a></q>\';k+=\' <q z="\'+m.u+\'"><a F=\\"G:H(0);\\">\'+m.Z+\'</a></q>\';k+=\' <q z="\'+m.C+\'"><a F=\\"G:H(0);\\">\'+m.10+\'</a></q>\';3(m.17)k+=\' <q z="\'+m.D+\'"><a F=\\"G:H(0);\\">\'+m.16+\'</a></q>\'};k+=m.13;$(f).1I(k)};3(m.E){1J(4 i=0;i<s;i++){$(1K.1L("o")).1c(\'z\',m.y+(i+1)).1M(\'<a 1d=\'+i+\' F=\\"G:H(0);\\">\'+(i+1)+\'</a>\').1N($("#"+m.y)).I(5(){8($("a",$(U)).1c(\'1d\'),9)})}}A{$("a","#"+m.C).I(5(){8("J",9)});$("a","#"+m.u).I(5(){8("1e",9)});$("a","#"+m.v).I(5(){8("1f",9)});$("a","#"+m.D).I(5(){8("V",9)})};5 X(i){i=1O(i)+1;$("o","#"+m.y).1P("1g");$("o#"+m.y+i).1Q("1g")};5 Y(){3(t>j)t=0;3(t<0)t=j;3(!m.L){$("7",f).r("W-N",(t*w*-1))}A{$("7",f).r("W-N",(t*h*-1))}g=9;3(m.E)X(t)};5 8(a,b){3(g){g=6;4 c=t;1R(a){O"J":t=(c>=j)?(m.x?t+1:j):t+1;K;O"1e":t=(t<=0)?(m.x?t-1:0):t-1;K;O"1f":t=0;K;O"V":t=j;K;1S:t=a;K};4 d=1T.1U(c-t);4 e=d*m.R;3(!m.L){p=(t*w*-1);$("7",f).8({1V:p},{1h:6,1i:e,1j:Y})}A{p=(t*h*-1);$("7",f).8({1W:p},{1h:6,1i:e,1j:Y})};3(!m.x&&m.Q){3(t==j){$("a","#"+m.C).B();$("a","#"+m.D).B()}A{$("a","#"+m.C).P();$("a","#"+m.D).P()};3(t==0){$("a","#"+m.u).B();$("a","#"+m.v).B()}A{$("a","#"+m.u).P();$("a","#"+m.v).P()}};3(b)1X(l);3(m.S&&a=="J"&&!b){;l=1k(5(){8("J",6)},d*m.R+m.T)}}};4 l;3(m.S){;l=1k(5(){8("J",6)},m.T)};3(m.E)X(0);3(!m.x&&m.Q){$("a","#"+m.u).B();$("a","#"+m.v).B()}})}})(1Y);',62,123,'|||if|var|function|false|ul|animate|true|||||||||||||||li||span|css|||prevId|firstId||continuous|numericId|id|else|hide|nextId|lastId|numeric|href|javascript|void|click|next|break|vertical|width|left|case|show|controlsFade|speed|auto|pause|this|last|margin|setCurrent|adjust|prevText|nextText|controlsShow|controlsBefore|controlsAfter|firstText|firstShow|lastText|lastShow|height|child|clone|ol|attr|rel|prev|first|current|queue|duration|complete|setTimeout|fn|easySlider|prevBtn|Previous|nextBtn|Next|firstBtn|First|lastBtn|Last|800|2000|controls|extend|each|length|overflow|hidden|prepend|px|append|nth|float|after|for|document|createElement|html|appendTo|parseInt|removeClass|addClass|switch|default|Math|abs|marginLeft|marginTop|clearTimeout|jQuery'.split('|'),0,{}))

eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('(2(a){4 b=(a.U.V?"1d":"1e")+".7",c=1f.1g!=1h;a.7={W:{9:"[0-9]",a:"[A-X-z]","*":"[A-X-1i-9]"},H:"1j"},a.1k.Y({x:2(a,b){3(6.y!=0){3(Z a=="10"){b=Z b=="10"?b:a;5 6.M(2(){3(6.N)6.N(a,b);C 3(6.11){4 c=6.11();c.1l(!0),c.1m("O",b),c.12("O",a),c.1n()}})}3(6[0].N)a=6[0].1o,b=6[0].1p;C 3(P.Q&&P.Q.13){4 c=P.Q.13();a=0-c.1q().12("O",-1r),b=a+c.1s.y}5{D:a,E:b}}},I:2(){5 6.14("I")},7:2(d,e){3(!d&&6.y>0){4 f=a(6[0]);5 f.15(a.7.H)()}e=a.Y({B:"1t",R:F},e);4 g=a.7.W,h=[],i=d.y,j=F,k=d.y;a.M(d.16(""),2(a,b){b=="?"?(k--,i=a):g[b]?(h.17(1u 1v(g[b])),j==F&&(j=h.y-1)):h.17(F)});5 6.14("I").M(2(){2 v(a){4 b=f.w(),c=-1;J(4 d=0,g=0;d<k;d++)3(h[d]){l[d]=e.B;S(g++<b.y){4 m=b.18(g-1);3(h[d].K(m)){l[d]=m,c=d;L}}3(g>b.y)L}C l[d]==b.18(g)&&d!=i&&(g++,c=d);3(!a&&c+1<i)f.w(""),t(0,k);C 3(a||c+1>=i)u(),a||f.w(f.w().1w(0,c+1));5 i?d:j}2 u(){5 f.w(l.19("")).w()}2 t(a,b){J(4 c=a;c<b&&c<k;c++)h[c]&&(l[c]=e.B)}2 s(a){4 b=a.1a,c=f.x();3(a.1x||a.1y||a.1z||b<1A)5!0;3(b){c.E-c.D!=0&&(t(c.D,c.E),p(c.D,c.E-1));4 d=n(c.D-1);3(d<k){4 g=1B.1C(b);3(h[d].K(g)){q(d),l[d]=g,u();4 i=n(d);f.x(i),e.R&&i>=k&&e.R.1D(f)}}5!1}}2 r(a){4 b=a.1a;3(b==8||b==T||c&&b==1E){4 d=f.x(),e=d.D,g=d.E;g-e==0&&(e=b!=T?o(e):g=n(e-1),g=b==T?n(g):g),t(e,g),p(e,g-1);5!1}3(b==1F){f.w(m),f.x(0,v());5!1}}2 q(a){J(4 b=a,c=e.B;b<k;b++)3(h[b]){4 d=n(b),f=l[b];l[b]=c;3(d<k&&h[d].K(f))c=f;C L}}2 p(a,b){3(!(a<0)){J(4 c=a,d=n(b);c<k;c++)3(h[c]){3(d<k&&h[c].K(l[d]))l[c]=l[d],l[d]=e.B;C L;d=n(d)}u(),f.x(1G.1H(j,a))}}2 o(a){S(--a>=0&&!h[a]);5 a}2 n(a){S(++a<=k&&!h[a]);5 a}4 f=a(6),l=a.1b(d.16(""),2(a,b){3(a!="?")5 g[a]?e.B:a}),m=f.w();f.15(a.7.H,2(){5 a.1b(l,2(a,b){5 h[b]&&a!=e.B?a:F}).19("")}),f.1I("1J")||f.1K("I",2(){f.1L(".7").1M(a.7.H)}).G("1N.7",2(){m=f.w();4 b=v();u();4 c=2(){b==d.y?f.x(0,b):f.x(b)};(a.U.V?c:2(){1c(c,0)})()}).G("1O.7",2(){v(),f.w()!=m&&f.1P()}).G("1Q.7",r).G("1R.7",s).G(b,2(){1c(2(){f.x(v(!0))},0)}),v()})}})})(1S)',62,117,'||function|if|var|return|this|mask|||||||||||||||||||||||||val|caret|length|||placeholder|else|begin|end|null|bind|dataName|unmask|for|test|break|each|setSelectionRange|character|document|selection|completed|while|46|browser|msie|definitions|Za|extend|typeof|number|createTextRange|moveStart|createRange|trigger|data|split|push|charAt|join|which|map|setTimeout|paste|input|window|orientation|undefined|z0|rawMaskFn|fn|collapse|moveEnd|select|selectionStart|selectionEnd|duplicate|1e5|text|_|new|RegExp|substring|ctrlKey|altKey|metaKey|32|String|fromCharCode|call|127|27|Math|max|attr|readonly|one|unbind|removeData|focus|blur|change|keydown|keypress|jQuery'.split('|'),0,{}))

eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('(5($){4 g=\'1s\',15=\'1t\',16=\'1u\';4 h=\'[S 1v]\',F=\'[S 1w]\',17=\'[S 18]\';4 n=1,G=\'%\',L=/^[^<]*(<[\\w\\W]+>)[^>]*$/,q=1x.1y.T;5 M(a,b){19($.U(a,b),a);}5 V(a){4 b=[];7(q.o(a)!==h)6 B;C(4 i=0,l=a.u;i<l;i++)b[i]=a[i].D;6 b.u?b.1z().v(\'.\').N(/(\\b\\d+\\b)\\.(?:\\1(\\.|$))+/g,\'$1$2\'):B}5 H(a,t){4 f,8=[],t=t||G,9=q.o(a);7(9===17)6 a.D?[a]:B;7(9!==h)6[$.O(a,t)];7(9===h)C(4 i=0,l=a.u;i<l;i++)7(f=H(a[i],t))8.1A(f[0]);6 8.u?8:B}$.8.U({A:5(b,t){4 b=q.o(b)===h?b:[b],X=\'\';E.Y(5(i){4 a=$.O(E,t);C(4 j=0;j<b.u;j++)X+=a.o(b[j],i,j,b,a)});6 X}});$.Y({1a:\'1B\',1b:\'1C\',1c:\'1D\'},5(e,f){$.8[\'A\'+e]=5(b,c,t){4 d,Z,10=$.A(b,c,t),$$=!L.P(10)?5(a){6 $(1E.1F(a))}:$;7(!!(d=V(H(b))))Z=Q 1G(\'(^|\\\\.)\'+d.x(\'.\').v(\'\\\\.(.*)?\')+\'(\\\\.|$)\');6 E.Y(5(){4 a=$$(10);$(E)[f](a);(a[0].1d===3?$(E):a).1H(\'A.\'+e,[a,Z])})}});$.U({A:5(a,b,t){4 c=\'\',t=t||G,8=H(a);7(8===B)M(Q 1e(\'1f 1g 1h 11 1i 1j $.A\'),{9:g});b=q.o(b)!==h?[b]:b;C(4 i=0,l=8.u;i<l;i++)C(4 j=0;j<b.u;j++)c+=8[i].o(b[j],i,j,b,8[i]);6 c},O:5(a,t){4 b,p,I,t=t||G,9=q.o(a);7(9===F&&L.P(a)){p=I=a;7(b=$.J[a])6 b}1I{p=9===F||a.1d?$(a):a 1k 12?a:1l;7(!p[0]||!(I=p[0].1J)&&!(I=p.1K()))M(Q 1e(\'1f 1g 1h 11 1i 1j $.O\'),{9:g});7(b=$.J[$.k(p[0],\'D\')])6 b}4 c=\'\',K,y=I.N(/\\s*<!\\[1L\\[\\s*|\\s*\\]\\]>\\s*|[\\r\\n\\t]/g,\'\').x(\'<\'+t).v(t+\'>\\1m\').x(t+\'>\');C(4 m=0,l=y.u;m<l;m++)c+=y[m].13(0)!==\'\\1m\'?"z+=\'"+y[m].N(/(\\\\|["\'])/g,\'\\\\$1\')+"\'":(y[m].13(1)===\'=\'?\';z+=(\'+y[m].14(2)+\');\':(y[m].13(1)===\'!\'?\';z+=$.1n((\'+y[m].14(2)+\'));\':\';\'+y[m].14(1)));c=\'1o{\'+(\'4 z="";\'+c+\';6 z;\').x("z+=\'\';").v(\'\').x(\'4 z="";z+=\').v(\'4 z=\')+\'}1p(e){e.9="\'+16+\'";e.1M=1q;e.11=1q.1N.T();19 e;}\';1o{4 d=Q 18(\'i, j, k, 8\',c)}1p(e){M(e,{9:15})}K=p 1k 12?$.k(p[0],\'D\',n):p;6 $.J[K]=(d.D=n++,d)},1O:5(a){4 b=q.o(a),K=b===F&&L.P(a)?a:$.k($(a)[0],\'D\');6 $.J[K]||B},1P:5(a){7(q.o(a)===F)G=a},1n:5(a){6 a.T().N(/&(?!\\w+;)/g,\'&#1Q;\').x(\'<\').v(\'&#1R;\').x(\'>\').v(\'&#1S;\').x(\'"\').v(\'&#1T;\').x("\'").v(\'&#1U;\')},J:{}});$.1V.1W.A={1X:5(d){4 e,R=d.R,k=!d.k?[]:q.o(d.k)!==h?[d.k]:d.k;7(!d.1r)d.1r=\'1a.1b.1c\';7(!k.u||!(e=V(H(k))))6;d.R=5(a,b,c){6!c||c.P(e)?R.1Y(E,[a,b]):1l}}}})(12);',62,123,'||||var|function|return|if|fn|type|||||||||||data||||call|elem|type_of||||length|join||split|arr|out|jqote|false|for|jqote_id|this|STR|tag|lambda|tmpl|jqotecache|index|qreg|raise|replace|jqotec|test|new|handler|object|toString|extend|dotted_ns||dom|each|regexp|str|template|jQuery|charAt|substr|JQOTE2_TMPL_COMP_ERROR|JQOTE2_TMPL_EXEC_ERROR|FUNC|Function|throw|app|pre|sub|nodeType|Error|Empty|or|undefined|passed|to|instanceof|null|x1b|jqotenc|try|catch|arguments|namespace|UndefinedTemplateError|TemplateCompilationError|TemplateExecutionError|Array|String|Object|prototype|sort|push|append|prepend|html|document|createTextNode|RegExp|trigger|else|innerHTML|text|CDATA|args|callee|jqotefn|jqotetag|38|60|62|34|39|event|special|add|apply'.split('|'),0,{}))



jQuery.cookie=function(a,b,c){if(arguments.length>1&&String(b)!=="[object Object]"){c=jQuery.extend({},c);if(b===null||b===undefined){c.expires=-1}if(typeof c.expires==='number'){var d=c.expires,t=c.expires=new Date();t.setDate(t.getDate()+d)}b=String(b);return(document.cookie=[encodeURIComponent(a),'=',c.raw?b:encodeURIComponent(b),c.expires?'; expires='+c.expires.toUTCString():'',c.path?'; path='+c.path:'',c.domain?'; domain='+c.domain:'',c.secure?'; secure':''].join(''))}c=b||{};var e,decode=c.raw?function(s){return s}:decodeURIComponent;return(e=new RegExp('(?:^|; )'+encodeURIComponent(a)+'=([^;]*)').exec(document.cookie))?decode(e[1]):null};

(function($){var e=/["\\\x00-\x1f\x7f-\x9f]/g,meta={'\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"':'\\"','\\':'\\\\'};$.toJSON=typeof JSON==='object'&&JSON.stringify?JSON.stringify:function(o){if(o===null){return'null'}var a=typeof o;if(a==='undefined'){return undefined}if(a==='number'||a==='boolean'){return''+o}if(a==='string'){return $.quoteString(o)}if(a==='object'){if(typeof o.toJSON==='function'){return $.toJSON(o.toJSON())}if(o.constructor===Date){var b=o.getUTCMonth()+1,day=o.getUTCDate(),year=o.getUTCFullYear(),hours=o.getUTCHours(),minutes=o.getUTCMinutes(),seconds=o.getUTCSeconds(),milli=o.getUTCMilliseconds();if(b<10){b='0'+b}if(day<10){day='0'+day}if(hours<10){hours='0'+hours}if(minutes<10){minutes='0'+minutes}if(seconds<10){seconds='0'+seconds}if(milli<100){milli='0'+milli}if(milli<10){milli='0'+milli}return'"'+year+'-'+b+'-'+day+'T'+hours+':'+minutes+':'+seconds+'.'+milli+'Z"'}if(o.constructor===Array){var c=[];for(var i=0;i<o.length;i++){c.push($.toJSON(o[i])||'null')}return'['+c.join(',')+']'}var d,val,pairs=[];for(var k in o){a=typeof k;if(a==='number'){d='"'+k+'"'}else if(a==='string'){d=$.quoteString(k)}else{continue}a=typeof o[k];if(a==='function'||a==='undefined'){continue}val=$.toJSON(o[k]);pairs.push(d+':'+val)}return'{'+pairs.join(',')+'}'}};$.evalJSON=typeof JSON==='object'&&JSON.parse?JSON.parse:function(a){return eval('('+a+')')};$.secureEvalJSON=typeof JSON==='object'&&JSON.parse?JSON.parse:function(a){var b=a.replace(/\\["\\\/bfnrtu]/g,'@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,']').replace(/(?:^|:|,)(?:\s*\[)+/g,'');if(/^[\],:{}\s]*$/.test(b)){return eval('('+a+')')}else{throw new SyntaxError('Error parsing JSON, source is not valid.');}};$.quoteString=function(b){if(b.match(e)){return'"'+b.replace(e,function(a){var c=meta[a];if(typeof c==='string'){return c}c=a.charCodeAt();return'\\u00'+Math.floor(c/16).toString(16)+(c%16).toString(16)})+'"'}return'"'+b+'"'}})(jQuery);

;(function(d){var k=d.scrollTo=function(a,i,e){d(window).scrollTo(a,i,e)};k.defaults={axis:'xy',duration:parseFloat(d.fn.jquery)>=1.3?0:1};k.window=function(a){return d(window)._scrollable()};d.fn._scrollable=function(){return this.map(function(){var a=this,i=!a.nodeName||d.inArray(a.nodeName.toLowerCase(),['iframe','#document','html','body'])!=-1;if(!i)return a;var e=(a.contentWindow||a).document||a.ownerDocument||a;return d.browser.safari||e.compatMode=='BackCompat'?e.body:e.documentElement})};d.fn.scrollTo=function(n,j,b){if(typeof j=='object'){b=j;j=0}if(typeof b=='function')b={onAfter:b};if(n=='max')n=9e9;b=d.extend({},k.defaults,b);j=j||b.speed||b.duration;b.queue=b.queue&&b.axis.length>1;if(b.queue)j/=2;b.offset=p(b.offset);b.over=p(b.over);return this._scrollable().each(function(){var q=this,r=d(q),f=n,s,g={},u=r.is('html,body');switch(typeof f){case'number':case'string':if(/^([+-]=)?\d+(\.\d+)?(px|%)?$/.test(f)){f=p(f);break}f=d(f,this);case'object':if(f.is||f.style)s=(f=d(f)).offset()}d.each(b.axis.split(''),function(a,i){var e=i=='x'?'Left':'Top',h=e.toLowerCase(),c='scroll'+e,l=q[c],m=k.max(q,i);if(s){g[c]=s[h]+(u?0:l-r.offset()[h]);if(b.margin){g[c]-=parseInt(f.css('margin'+e))||0;g[c]-=parseInt(f.css('border'+e+'Width'))||0}g[c]+=b.offset[h]||0;if(b.over[h])g[c]+=f[i=='x'?'width':'height']()*b.over[h]}else{var o=f[h];g[c]=o.slice&&o.slice(-1)=='%'?parseFloat(o)/100*m:o}if(/^\d+$/.test(g[c]))g[c]=g[c]<=0?0:Math.min(g[c],m);if(!a&&b.queue){if(l!=g[c])t(b.onAfterFirst);delete g[c]}});t(b.onAfter);function t(a){r.animate(g,j,b.easing,a&&function(){a.call(this,n,b)})}}).end()};k.max=function(a,i){var e=i=='x'?'Width':'Height',h='scroll'+e;if(!d(a).is('html,body'))return a[h]-d(a)[e.toLowerCase()]();var c='client'+e,l=a.ownerDocument.documentElement,m=a.ownerDocument.body;return Math.max(l[h],m[h])-Math.min(l[c],m[c])};function p(a){return typeof a=='object'?a:{top:a,left:a}}})(jQuery);



eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('(6($){$.1S("1T.1U",{M:{b:"16.b",c:"16.c",d:"16.d",7:"16.7",N:q,w:"",O:"",1V:15,1f:10,1g:1,17:"",1s:"I",C:5,h:10,1t:"",1u:5,s:""},1W:6(){i 4=8,o=8.M,2=8.j;2.3("7",2.P(o.7));2.3("c",2.P(o.c));2.3("b",2.P(o.b));2.3("d",2.P(o.d));2.3("Q",1);2.3("1X",2.1Y().1h);2.3("g",0);2.3("1Z",2.P(o.b).1v());2.3("R",0);2.3("D",0);2.3("S",n);2.3("T",n);2.3("h",n);2.3("18",n);2.3("U",0);2.3("V","I");2.3("E",f);2.3("J",n);2.3("W",f);2.3("F",n);2.3("1i",2.3("d").t(o.O));2.3("19",f);2.3("1j",q);2.3("X",f);9(o.17!=="1w"){1k(o.1t){r"1w":4.1l();m;r"20":4.1l();2.3("18",21(6(){4.1x("22")},(o.1u*23)));m;1m:m}}2.3("c").u("1y",6(e){2.3("g",5);9(2.3("g")===1z){2.3("g",0)}});2.3("c").u("1a",6(){2.3("S",1n(6(){9(2.3("g")>0&&2.3("X")){2.3("7").a(2.3("7").a()+(2.3("g")*2.3("Q")));4.v()}},o.1f));4.k("24")});2.3("c").u("1b",6(){l(2.3("S"));2.3("g",0)});2.3("c").u("1c",6(){2.3("Q",o.1g)});$("25").u("26",6(){2.3("Q",1)});2.3("b").u("1y",6(e){2.3("g",5);9(2.3("g")===1z){2.3("g",0)}});2.3("b").u("1a",6(){2.3("T",1n(6(){9(2.3("g")>0&&2.3("X")){i 1A=2.3("7").a()-(2.3("g"));2.3("7").a(1A);4.v()}},o.1f));4.k("27")});2.3("b").u("1b",6(){l(2.3("T"));2.3("g",0)});2.3("b").u("1c",6(){2.3("Q",o.1g)});$(28).u("29",6(){9(!(o.N)){4.v()}4.k("2a")});9(o.w.x>0){4.1B(o.w)}y{4.Y()}9(o.N){4.Z()}9((o.17.x>0)&&!(o.N)&&(o.w.x<=0)){4.1o()}},1l:6(A){i 4=8,2=8.j;9(A!==1C){2.3("b").1D("1E","0.0");2.3("c").1D("1E","0.0");2.3("b").1d("11");2.3("c").1d("12");2.3("b").1e(A,0.1F);2.3("c").1e(A,0.1F)}y{2.3("b").1d("11");2.3("b").G("H");2.3("c").1d("12");2.3("c").G("H")}4.v()},1x:6(A){i 2=8.j;9(A!==1C){2.3("b").1e(A,0.0,6(){2.3("b").K("11")});2.3("c").1e(A,0.0,6(){2.3("c").K("12")})}y{2.3("b").K("11");2.3("b").G("H");2.3("c").K("12");2.3("c").G("H")}},v:6(){2b q},1p:6(1G,13){i 4=8,2=8.j,o=8.M,p=0,14=q;1k(1G){r"B":2.3("g",0);4.k("2c");m;r"2d":2.3("d").t(o.O).1q(6(){9((o.s.x>0)&&(($(8).1H("1I"))===o.s)){2.3("D",p);14=f}p=p+$(8).z(f)});2.3("g",2.3("D"));4.k("2e");m;r"1r":2.3("g",2.3("R"));4.k("2f");m;r"2g":9(!(2h(13))){2.3("d").t(o.O).1q(6(1J){9(1J===(13-1)){2.3("g",p)}p=p+$(8).z(f)})}4.k("2i",n,{"13":13});m;1m:m}2.3("7").a(2.3("g"));4.v()},2j:6(w,1K){i 4=8,2=8.j;$.2k(w,6(3){9(1K==="B"){2.3("d").t(":B").2l(3)}y{2.3("d").t(":1r").2m(3)}4.Y();4.v()})},1B:6(w){i 4=8,2=8.j;2.3("d").2n(w,6(){4.Y();4.1p("B");4.v();2.3("D",0)})},Y:6(){i p=0,14=q,o=8.M,2=8.j,4=8;2.3("d").t(o.O).1q(6(){9((o.s.x>0)&&(($(8).1H("1I"))===o.s)){2.3("D",p);14=f}p=p+$(8).z(f)});9(!(14)){2.3("s","")}2.3("R",p);2.3("d").1v(2.3("R"));2.3("7").a(2.3("D"));2.3("g",2.3("D"));9(!(2.3("1j"))){9((o.17.x>0)&&!(o.N)&&(o.w.x>0)){4.1o();2.3("1j",f)}}},2o:6(){i 4=8,2=8.j;l(2.3("h"));2.3("h",n);4.v();4.k("2p")},1o:6(){i 4=8,2=8.j,o=8.M;4.v();l(2.3("h"));2.3("h",n);4.k("2q");2.3("h",1n(6(){9(!(2.3("19"))||(2.3("R")<=(2.3("7").2r()))){l(2.3("h"));2.3("h",n)}y{2.3("U",2.3("7").a());1k(o.1s){r"I":2.3("7").a(2.3("7").a()+o.C);9(2.3("U")===2.3("7").a()){4.k("1L");l(2.3("h"));2.3("h",n);4.k("1M")}m;r"1h":2.3("7").a(2.3("7").a()-o.C);9(2.3("U")===2.3("7").a()){4.k("1N");l(2.3("h"));2.3("h",n);4.k("1M")}m;r"2s":9(2.3("V")==="I"){2.3("7").a(2.3("7").a()+(o.C))}y{2.3("7").a(2.3("7").a()-(o.C))}9(2.3("U")===2.3("7").a()){9(2.3("V")==="I"){2.3("V","1h");4.k("1L")}y{2.3("V","I");4.k("1N")}}m;r"2t":9(2.3("E")){9((o.s.x>0)&&(2.3("W"))){2.3("J",$("#"+o.s).z(f));2.3("W",q)}y{2.3("J",2.3("d").t(":B").z(f))}2.3("E",q)}2.3("7").a(2.3("7").a()+o.C);9(2.3("J")<=2.3("7").a()){2.3("F",2.3("d").t(":B").1O());2.3("d").2u(2.3("F"));2.3("7").a(2.3("7").a()-2.3("F").z(f));2.3("E",f)}m;r"2v":9(2.3("E")){9((o.s.x>0)&&(2.3("W"))){2.3("J",$("#"+o.s).z(f));2.3("W",q)}y{2.3("J",2.3("d").t(":B").z(f))}2.3("E",q)}2.3("7").a(2.3("7").a()-o.C);9(2.3("7").a()===0){2.3("F",2.3("d").t(":1r").1O());2.3("d").2w(2.3("F"));2.3("7").a(2.3("7").a()+2.3("F").z(f));2.3("E",f)}m;1m:m}}},o.h))},2x:6(){i 4=8,2=8.j;2.3("d").1P(2.3("1i"));4.Y();4.1p("B")},1Q:6(){i 2=8.j;2.3("19",f);2.1Q()},Z:6(){i 2=8.j;2.3("19",q);2.Z()},2y:6(){i 2=8.j;2.3("X",f)},2z:6(){i 2=8.j;l(2.3("h"));l(2.3("S"));l(2.3("T"));l(2.3("18"));2.3("X",q)},1R:6(){i 2=8.j;l(2.3("h"));l(2.3("S"));l(2.3("T"));l(2.3("18"));2.3("c").L("1a");2.3("c").L("1b");2.3("c").L("1c");2.3(".b").L("1a");2.3("b").L("1b");2.3("b").L("1c");2.3("d").1P(2.3("1i"));2.3("d").G("H");2.3("c").G("H");2.3("b").G("H");2.3("7").a(0);2.3("b").K("11");2.3("c").K("12");2.3("c").Z();2.3("b").Z();$.2A.2B.1R.2C(8,2D)}})})(2E);',62,165,'||el|data|self||function|scrollWrapper|this|if|scrollLeft|scrollingHotSpotLeft|scrollingHotSpotRight|scrollableArea||true|scrollXPos|autoScrollInterval|var|element|_trigger|clearInterval|break|null||tempScrollableAreaWidth|false|case|startAtElementId|children|bind|_showHideHotSpots|ajaxContentURL|length|else|outerWidth|fadeSpeed|first|autoScrollStep|startingPosition|getNextElementWidth|swappedElement|removeAttr|style|right|swapAt|removeClass|unbind|options|hiddenOnStart|countOnlyClass|find|speedBooster|scrollableAreaWidth|rightScrollInterval|leftScrollInterval|previousScrollLeft|pingPongDirection|startAtElementHasNotPassed|enabled|recalculateScrollableArea|hide||scrollingHotSpotLeftVisible|scrollingHotSpotRightVisible|elementNumber|foundStartAtElement||div|autoScroll|hideHotSpotBackgroundsInterval|visible|mouseover|mouseout|mousedown|addClass|fadeTo|scrollInterval|mouseDownSpeedBooster|left|originalElements|initialAjaxContentLoaded|switch|showHotSpotBackgrounds|default|setInterval|startAutoScroll|moveToElement|each|last|autoScrollDirection|visibleHotSpots|hotSpotsVisibleTime|width|always|hideHotSpotBackgrounds|mouseenter|Infinity|sl|replaceContent|undefined|css|opacity|35|moveTo|attr|id|index|addWhere|autoScrollRightLimitReached|autoScrollIntervalStopped|autoScrollLeftLimitReached|detach|html|show|destroy|widget|thomaskahn|smoothDivScroll|scrollStep|_create|motherElementOffset|offset|hotSpotWidth|onstart|setTimeout|slow|1000|mouseOverRightHotSpot|body|mouseup|mouseOverLeftHotSpot|window|resize|windowResized|return|movedToFirstElement|start|movedToStartElement|movedToLastElement|number|isNaN|movedToElementNumber|addContent|get|before|after|load|stopAutoScroll|autoScrollStopped|autoScrollStarted|innerWidth|backandforth|endlessloopright|append|endlessloopleft|prepend|restoreOriginalElements|enable|disable|Widget|prototype|apply|arguments|jQuery'.split('|'),0,{}))




/*
 * jQuery File Upload Plugin 5.10.0
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, document, Blob, FormData, location */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'jquery.ui.widget'
        ], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // The FileReader API is not actually used, but works as feature detection,
    // as e.g. Safari supports XHR file uploads via the FormData API,
    // but not non-multipart XHR file uploads:
    $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;

    // The fileupload widget listens for change events on file input fields defined
    // via fileInput setting and paste or drop events of the given dropZone.
    // In addition to the default jQuery Widget methods, the fileupload widget
    // exposes the "add" and "send" methods, to add or directly send files using
    // the fileupload API.
    // By default, files added via file input selection, paste, drag & drop or
    // "add" method are uploaded immediately, but it is possible to override
    // the "add" callback option to queue file uploads.
    $.widget('blueimp.fileupload', {

        options: {
            // The namespace used for event handler binding on the dropZone and
            // fileInput collections.
            // If not set, the name of the widget ("fileupload") is used.
            namespace: undefined,
            // The drop target collection, by the default the complete document.
            // Set to null or an empty collection to disable drag & drop support:
            dropZone: $(document),
            // The file input field collection, that is listened for change events.
            // If undefined, it is set to the file input fields inside
            // of the widget element on plugin initialization.
            // Set to null or an empty collection to disable the change listener.
            fileInput: undefined,
            // By default, the file input field is replaced with a clone after
            // each input field change event. This is required for iframe transport
            // queues and allows change events to be fired for the same file
            // selection, but can be disabled by setting the following option to false:
            replaceFileInput: true,
            // The parameter name for the file form data (the request argument name).
            // If undefined or empty, the name property of the file input field is
            // used, or "files[]" if the file input name property is also empty,
            // can be a string or an array of strings:
            paramName: undefined,
            // By default, each file of a selection is uploaded using an individual
            // request for XHR type uploads. Set to false to upload file
            // selections in one request each:
            singleFileUploads: true,
            // To limit the number of files uploaded with one XHR request,
            // set the following option to an integer greater than 0:
            limitMultiFileUploads: undefined,
            // Set the following option to true to issue all file upload requests
            // in a sequential order:
            sequentialUploads: true,
            // To limit the number of concurrent uploads,
            // set the following option to an integer greater than 0:
            limitConcurrentUploads: undefined,
            // Set the following option to true to force iframe transport uploads:
            forceIframeTransport: false,
            // Set the following option to the location of a redirect url on the
            // origin server, for cross-domain iframe transport uploads:
            redirect: undefined,
            // The parameter name for the redirect url, sent as part of the form
            // data and set to 'redirect' if this option is empty:
            redirectParamName: undefined,
            // Set the following option to the location of a postMessage window,
            // to enable postMessage transport uploads:
            postMessage: undefined,
            // By default, XHR file uploads are sent as multipart/form-data.
            // The iframe transport is always using multipart/form-data.
            // Set to false to enable non-multipart XHR uploads:
            multipart: true,
            // To upload large files in smaller chunks, set the following option
            // to a preferred maximum chunk size. If set to 0, null or undefined,
            // or the browser does not support the required Blob API, files will
            // be uploaded as a whole.
            maxChunkSize: undefined,
            // When a non-multipart upload or a chunked multipart upload has been
            // aborted, this option can be used to resume the upload by setting
            // it to the size of the already uploaded bytes. This option is most
            // useful when modifying the options object inside of the "add" or
            // "send" callbacks, as the options are cloned for each file upload.
            uploadedBytes: undefined,
            // By default, failed (abort or error) file uploads are removed from the
            // global progress calculation. Set the following option to false to
            // prevent recalculating the global progress data:
            recalculateProgress: true,

            // Additional form data to be sent along with the file uploads can be set
            // using this option, which accepts an array of objects with name and
            // value properties, a function returning such an array, a FormData
            // object (for XHR file uploads), or a simple object.
            // The form of the first fileInput is given as parameter to the function:
            formData: function (form) {
                return form.serializeArray();
            },

            // The add callback is invoked as soon as files are added to the fileupload
            // widget (via file input selection, drag & drop, paste or add API call).
            // If the singleFileUploads option is enabled, this callback will be
            // called once for each file in the selection for XHR file uplaods, else
            // once for each file selection.
            // The upload starts when the submit method is invoked on the data parameter.
            // The data object contains a files property holding the added files
            // and allows to override plugin options as well as define ajax settings.
            // Listeners for this callback can also be bound the following way:
            // .bind('fileuploadadd', func);
            // data.submit() returns a Promise object and allows to attach additional
            // handlers using jQuery's Deferred callbacks:
            // data.submit().done(func).fail(func).always(func);
            add: function (e, data) {
                data.submit();
            },

            // Other callbacks:
            // Callback for the submit event of each file upload:
            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);
            // Callback for the start of each file upload request:
            // send: function (e, data) {}, // .bind('fileuploadsend', func);
            // Callback for successful uploads:
            // done: function (e, data) {}, // .bind('fileuploaddone', func);
            // Callback for failed (abort or error) uploads:
            // fail: function (e, data) {}, // .bind('fileuploadfail', func);
            // Callback for completed (success, abort or error) requests:
            // always: function (e, data) {}, // .bind('fileuploadalways', func);
            // Callback for upload progress events:
            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);
            // Callback for global upload progress events:
            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);
            // Callback for uploads start, equivalent to the global ajaxStart event:
            // start: function (e) {}, // .bind('fileuploadstart', func);
            // Callback for uploads stop, equivalent to the global ajaxStop event:
            // stop: function (e) {}, // .bind('fileuploadstop', func);
            // Callback for change events of the fileInput collection:
            // change: function (e, data) {}, // .bind('fileuploadchange', func);
            // Callback for paste events to the dropZone collection:
            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);
            // Callback for drop events of the dropZone collection:
            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);
            // Callback for dragover events of the dropZone collection:
            // dragover: function (e) {}, // .bind('fileuploaddragover', func);

            // The plugin options are used as settings object for the ajax calls.
            // The following are jQuery ajax settings required for the file uploads:
            processData: false,
            contentType: false,
            cache: false
        },

        // A list of options that require a refresh after assigning a new value:
        _refreshOptionsList: [
            'namespace',
            'dropZone',
            'fileInput',
            'multipart',
            'forceIframeTransport'
        ],

        _isXHRUpload: function (options) {
            return !options.forceIframeTransport &&
                ((!options.multipart && $.support.xhrFileUpload) ||
                $.support.xhrFormDataFileUpload);
        },

        _getFormData: function (options) {
            var formData;
            if (typeof options.formData === 'function') {
                return options.formData(options.form);
            } else if ($.isArray(options.formData)) {
                return options.formData;
            } else if (options.formData) {
                formData = [];
                $.each(options.formData, function (name, value) {
                    formData.push({name: name, value: value});
                });
                return formData;
            }
            return [];
        },

        _getTotal: function (files) {
            var total = 0;
            $.each(files, function (index, file) {
                total += file.size || 1;
            });
            return total;
        },

        _onProgress: function (e, data) {
            if (e.lengthComputable) {
                var total = data.total || this._getTotal(data.files),
                    loaded = parseInt(
                        e.loaded / e.total * (data.chunkSize || total),
                        10
                    ) + (data.uploadedBytes || 0);
                this._loaded += loaded - (data.loaded || data.uploadedBytes || 0);
                data.lengthComputable = true;
                data.loaded = loaded;
                data.total = total;
                // Trigger a custom progress event with a total data property set
                // to the file size(s) of the current upload and a loaded data
                // property calculated accordingly:
                this._trigger('progress', e, data);
                // Trigger a global progress event for all current file uploads,
                // including ajax calls queued for sequential file uploads:
                this._trigger('progressall', e, {
                    lengthComputable: true,
                    loaded: this._loaded,
                    total: this._total
                });
            }
        },

        _initProgressListener: function (options) {
            var that = this,
                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            // Accesss to the native XHR object is required to add event listeners
            // for the upload progress event:
            if (xhr.upload) {
                $(xhr.upload).bind('progress', function (e) {
                    var oe = e.originalEvent;
                    // Make sure the progress event properties get copied over:
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function () {
                    return xhr;
                };
            }
        },

        _initXHRData: function (options) {
            var formData,
                file = options.files[0],
                // Ignore non-multipart setting if not supported:
                multipart = options.multipart || !$.support.xhrFileUpload,
                paramName = options.paramName[0];
            if (!multipart || options.blob) {
                // For non-multipart uploads and chunked uploads,
                // file meta data is not part of the request body,
                // so we transmit this data as part of the HTTP headers.
                // For cross domain requests, these headers must be allowed
                // via Access-Control-Allow-Headers or removed using
                // the beforeSend callback:
                options.headers = $.extend(options.headers, {
                    'X-File-Name': file.name,
                    'X-File-Type': file.type,
                    'X-File-Size': file.size
                });
                if (!options.blob) {
                    // Non-chunked non-multipart upload:
                    options.contentType = file.type;
                    options.data = file;
                } else if (!multipart) {
                    // Chunked non-multipart upload:
                    options.contentType = 'application/octet-stream';
                    options.data = options.blob;
                }
            }
            if (multipart && $.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    // window.postMessage does not allow sending FormData
                    // objects, so we just add the File/Blob objects to
                    // the formData array and let the postMessage window
                    // create the FormData object out of this array:
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            name: paramName,
                            value: options.blob
                        });
                    } else {
                        $.each(options.files, function (index, file) {
                            formData.push({
                                name: options.paramName[index] || paramName,
                                value: file
                            });
                        });
                    }
                } else {
                    if (options.formData instanceof FormData) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function (index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function (index, file) {
                            // File objects are also Blob instances.
                            // This check allows the tests to run with
                            // dummy objects:
                            if (file instanceof Blob) {
                                formData.append(
                                    options.paramName[index] || paramName,
                                    file,
                                    file.name
                                );
                            }
                        });
                    }
                }
                options.data = formData;
            }
            // Blob reference is not needed anymore, free memory:
            options.blob = null;
        },

        _initIframeSettings: function (options) {
            // Setting the dataType to iframe enables the iframe transport:
            options.dataType = 'iframe ' + (options.dataType || '');
            // The iframe transport accepts a serialized array as form data:
            options.formData = this._getFormData(options);
            // Add redirect url to form data on cross-domain uploads:
            if (options.redirect && $('<a></a>').prop('href', options.url)
                    .prop('host') !== location.host) {
                options.formData.push({
                    name: options.redirectParamName || 'redirect',
                    value: options.redirect
                });
            }
        },

        _initDataSettings: function (options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    // Setting the dataType to postmessage enables the
                    // postMessage transport:
                    options.dataType = 'postmessage ' + (options.dataType || '');
                }
            } else {
                this._initIframeSettings(options, 'iframe');
            }
        },

        _getParamName: function (options) {
            var fileInput = $(options.fileInput),
                paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function () {
                    var input = $(this),
                        name = input.prop('name') || 'files[]',
                        i = (input.prop('files') || [1]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [fileInput.prop('name') || 'files[]'];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [paramName];
            }
            return paramName;
        },

        _initFormSettings: function (options) {
            // Retrieve missing options from the input field and the
            // associated form, if available:
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop('form'));
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop('action') || location.href;
            }
            // The HTTP request method must be "POST" or "PUT":
            options.type = (options.type || options.form.prop('method') || '')
                .toUpperCase();
            if (options.type !== 'POST' && options.type !== 'PUT') {
                options.type = 'POST';
            }
        },

        _getAJAXSettings: function (data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },

        // Maps jqXHR callbacks to the equivalent
        // methods of the given Promise object:
        _enhancePromise: function (promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },

        // Creates and returns a Promise object enhanced with
        // the jqXHR methods abort, success, error and complete:
        _getXHRPromise: function (resolveOrReject, context, args) {
            var dfd = $.Deferred(),
                promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },

        // Uploads a file in multiple, sequential requests
        // by splitting the file up in multiple blob chunks.
        // If the second parameter is true, only tests if the file
        // should be uploaded in chunks, but does not invoke any
        // upload requests:
        _chunkedUpload: function (options, testOnly) {
            var that = this,
                file = options.files[0],
                fs = file.size,
                ub = options.uploadedBytes = options.uploadedBytes || 0,
                mcs = options.maxChunkSize || fs,
                // Use the Blob methods with the slice implementation
                // according to the W3C Blob API specification:
                slice = file.webkitSlice || file.mozSlice || file.slice,
                upload,
                n,
                jqXHR,
                pipe;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                    options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = 'uploadedBytes';
                return this._getXHRPromise(
                    false,
                    options.context,
                    [null, 'error', file.error]
                );
            }
            // n is the number of blobs to upload,
            // calculated via filesize, uploaded bytes and max chunk size:
            n = Math.ceil((fs - ub) / mcs);
            // The chunk upload method accepting the chunk number as parameter:
            upload = function (i) {
                if (!i) {
                    return that._getXHRPromise(true, options.context);
                }
                // Upload the blobs in sequential order:
                return upload(i -= 1).pipe(function () {
                    // Clone the options object for each chunk upload:
                    var o = $.extend({}, options);
                    o.blob = slice.call(
                        file,
                        ub + i * mcs,
                        ub + (i + 1) * mcs
                    );
                    // Store the current chunk size, as the blob itself
                    // will be dereferenced after data processing:
                    o.chunkSize = o.blob.size;
                    // Process the upload data (the blob and potential form data):
                    that._initXHRData(o);
                    // Add progress listeners for this chunk upload:
                    that._initProgressListener(o);
                    jqXHR = ($.ajax(o) || that._getXHRPromise(false, o.context))
                        .done(function () {
                            // Create a progress event if upload is done and
                            // no progress event has been invoked for this chunk:
                            if (!o.loaded) {
                                that._onProgress($.Event('progress', {
                                    lengthComputable: true,
                                    loaded: o.chunkSize,
                                    total: o.chunkSize
                                }), o);
                            }
                            options.uploadedBytes = o.uploadedBytes +=
                                o.chunkSize;
                        });
                    return jqXHR;
                });
            };
            // Return the piped Promise object, enhanced with an abort method,
            // which is delegated to the jqXHR object of the current upload,
            // and jqXHR callbacks mapped to the equivalent Promise methods:
            pipe = upload(n);
            pipe.abort = function () {
                return jqXHR.abort();
            };
            return this._enhancePromise(pipe);
        },

        _beforeSend: function (e, data) {
            if (this._active === 0) {
                // the start callback is triggered when an upload starts
                // and no other uploads are currently running,
                // equivalent to the global ajaxStart event:
                this._trigger('start');
            }
            this._active += 1;
            // Initialize the global progress values:
            this._loaded += data.uploadedBytes || 0;
            this._total += this._getTotal(data.files);
        },

        _onDone: function (result, textStatus, jqXHR, options) {
            if (!this._isXHRUpload(options)) {
                // Create a progress event for each iframe load:
                this._onProgress($.Event('progress', {
                    lengthComputable: true,
                    loaded: 1,
                    total: 1
                }), options);
            }
            options.result = result;
            options.textStatus = textStatus;
            options.jqXHR = jqXHR;
            this._trigger('done', null, options);
        },

        _onFail: function (jqXHR, textStatus, errorThrown, options) {
            options.jqXHR = jqXHR;
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            this._trigger('fail', null, options);
            if (options.recalculateProgress) {
                // Remove the failed (error or abort) file upload from
                // the global progress calculation:
                this._loaded -= options.loaded || options.uploadedBytes || 0;
                this._total -= options.total || this._getTotal(options.files);
            }
        },

        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
            this._active -= 1;
            options.textStatus = textStatus;
            if (jqXHRorError && jqXHRorError.always) {
                options.jqXHR = jqXHRorError;
                options.result = jqXHRorResult;
            } else {
                options.jqXHR = jqXHRorResult;
                options.errorThrown = jqXHRorError;
            }
            this._trigger('always', null, options);
            if (this._active === 0) {
                // The stop callback is triggered when all uploads have
                // been completed, equivalent to the global ajaxStop event:
                this._trigger('stop');
                // Reset the global progress values:
                this._loaded = this._total = 0;
            }
        },

        _onSend: function (e, data) {
            var that = this,
                jqXHR,
                slot,
                pipe,
                options = that._getAJAXSettings(data),
                send = function (resolve, args) {
                    that._sending += 1;
                    jqXHR = jqXHR || (
                        (resolve !== false &&
                        that._trigger('send', e, options) !== false &&
                        (that._chunkedUpload(options) || $.ajax(options))) ||
                        that._getXHRPromise(false, options.context, args)
                    ).done(function (result, textStatus, jqXHR) {
                        that._onDone(result, textStatus, jqXHR, options);
                    }).fail(function (jqXHR, textStatus, errorThrown) {
                        that._onFail(jqXHR, textStatus, errorThrown, options);
                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
                        that._sending -= 1;
                        that._onAlways(
                            jqXHRorResult,
                            textStatus,
                            jqXHRorError,
                            options
                        );
                        if (options.limitConcurrentUploads &&
                                options.limitConcurrentUploads > that._sending) {
                            // Start the next queued upload,
                            // that has not been aborted:
                            var nextSlot = that._slots.shift();
                            while (nextSlot) {
                                if (!nextSlot.isRejected()) {
                                    nextSlot.resolve();
                                    break;
                                }
                                nextSlot = that._slots.shift();
                            }
                        }
                    });
                    return jqXHR;
                };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads ||
                    (this.options.limitConcurrentUploads &&
                    this.options.limitConcurrentUploads <= this._sending)) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.pipe(send);
                } else {
                    pipe = (this._sequence = this._sequence.pipe(send, send));
                }
                // Return the piped Promise object, enhanced with an abort method,
                // which is delegated to the jqXHR object of the current upload,
                // and jqXHR callbacks mapped to the equivalent Promise methods:
                pipe.abort = function () {
                    var args = [undefined, 'abort', 'abort'];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(args);
                        }
                        return send(false, args);
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },

        _onAdd: function (e, data) {
            var that = this,
                result = true,
                options = $.extend({}, this.options, data),
                limit = options.limitMultiFileUploads,
                paramName = this._getParamName(options),
                paramNameSet,
                paramNameSlice,
                fileSet,
                i;
            if (!(options.singleFileUploads || limit) ||
                    !this._isXHRUpload(options)) {
                fileSet = [data.files];
                paramNameSet = [paramName];
            } else if (!options.singleFileUploads && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < data.files.length; i += limit) {
                    fileSet.push(data.files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = data.files;
            $.each(fileSet || data.files, function (index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [element];
                newData.paramName = paramNameSet[index];
                newData.submit = function () {
                    newData.jqXHR = this.jqXHR =
                        (that._trigger('submit', e, this) !== false) &&
                        that._onSend(e, this);
                    return this.jqXHR;
                };
                return (result = that._trigger('add', e, newData));
            });
            return result;
        },

        // File Normalization for Gecko 1.9.1 (Firefox 3.5) support:
        _normalizeFile: function (index, file) {
            if (file.name === undefined && file.size === undefined) {
                file.name = file.fileName;
                file.size = file.fileSize;
            }
        },

        _replaceFileInput: function (input) {
            var inputClone = input.clone(true);
            $('<form></form>').append(inputClone)[0].reset();
            // Detaching allows to insert the fileInput on another form
            // without loosing the file input value:
            input.after(inputClone).detach();
            // Avoid memory leaks with the detached file input:
            $.cleanData(input.unbind('remove'));
            // Replace the original file input element in the fileInput
            // collection with the clone, which has been copied including
            // event handlers:
            this.options.fileInput = this.options.fileInput.map(function (i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            // If the widget has been initialized on the file input itself,
            // override this.element with the file input clone:
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },

        _onChange: function (e) {
            var that = e.data.fileupload,
                data = {
                    files: $.each($.makeArray(e.target.files), that._normalizeFile),
                    fileInput: $(e.target),
                    form: $(e.target.form)
                };
            if (!data.files.length) {
                // If the files property is not available, the browser does not
                // support the File API and we add a pseudo File object with
                // the input value as name with path information removed:
                data.files = [{name: e.target.value.replace(/^.*\\/, '')}];
            }
            if (that.options.replaceFileInput) {
                that._replaceFileInput(data.fileInput);
            }
            if (that._trigger('change', e, data) === false ||
                    that._onAdd(e, data) === false) {
                return false;
            }
        },

        _onPaste: function (e) {
            var that = e.data.fileupload,
                cbd = e.originalEvent.clipboardData,
                items = (cbd && cbd.items) || [],
                data = {files: []};
            $.each(items, function (index, item) {
                var file = item.getAsFile && item.getAsFile();
                if (file) {
                    data.files.push(file);
                }
            });
            if (that._trigger('paste', e, data) === false ||
                    that._onAdd(e, data) === false) {
                return false;
            }
        },

        _onDrop: function (e) {
            var that = e.data.fileupload,
                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer,
                data = {
                    files: $.each(
                        $.makeArray(dataTransfer && dataTransfer.files),
                        that._normalizeFile
                    )
                };
            if (that._trigger('drop', e, data) === false ||
                    that._onAdd(e, data) === false) {
                return false;
            }
            e.preventDefault();
        },

        _onDragOver: function (e) {
            var that = e.data.fileupload,
                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer;
            if (that._trigger('dragover', e) === false) {
                return false;
            }
            if (dataTransfer) {
                dataTransfer.dropEffect = dataTransfer.effectAllowed = 'copy';
            }
            e.preventDefault();
        },

        _initEventHandlers: function () {
            var ns = this.options.namespace;
            if (this._isXHRUpload(this.options)) {
                this.options.dropZone
                    .bind('dragover.' + ns, {fileupload: this}, this._onDragOver)
                    .bind('drop.' + ns, {fileupload: this}, this._onDrop)
                    .bind('paste.' + ns, {fileupload: this}, this._onPaste);
            }
            this.options.fileInput
                .bind('change.' + ns, {fileupload: this}, this._onChange);
        },

        _destroyEventHandlers: function () {
            var ns = this.options.namespace;
            this.options.dropZone
                .unbind('dragover.' + ns, this._onDragOver)
                .unbind('drop.' + ns, this._onDrop)
                .unbind('paste.' + ns, this._onPaste);
            this.options.fileInput
                .unbind('change.' + ns, this._onChange);
        },

        _setOption: function (key, value) {
            var refresh = $.inArray(key, this._refreshOptionsList) !== -1;
            if (refresh) {
                this._destroyEventHandlers();
            }
            $.Widget.prototype._setOption.call(this, key, value);
            if (refresh) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },

        _initSpecialOptions: function () {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input:file') ?
                        this.element : this.element.find('input:file');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
        },

        _create: function () {
            var options = this.options,
                dataOpts = $.extend({}, this.element.data());
            dataOpts[this.widgetName] = undefined;
            $.extend(options, dataOpts);
            options.namespace = options.namespace || this.widgetName;
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = this._loaded = this._total = 0;
            this._initEventHandlers();
        },

        destroy: function () {
            this._destroyEventHandlers();
            $.Widget.prototype.destroy.call(this);
        },

        enable: function () {
            $.Widget.prototype.enable.call(this);
            this._initEventHandlers();
        },

        disable: function () {
            this._destroyEventHandlers();
            $.Widget.prototype.disable.call(this);
        },

        // This method is exposed to the widget API and allows adding files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files property and can contain additional options:
        // .fileupload('add', {files: filesList});
        add: function (data) {
            if (!data || this.options.disabled) {
                return;
            }
            data.files = $.each($.makeArray(data.files), this._normalizeFile);
            this._onAdd(null, data);
        },

        // This method is exposed to the widget API and allows sending files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files property and can contain additional options:
        // .fileupload('send', {files: filesList});
        // The method returns a Promise object for the file upload call.
        send: function (data) {
            if (data && !this.options.disabled) {
                data.files = $.each($.makeArray(data.files), this._normalizeFile);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }

    });

}));



/*
 * jQuery Iframe Transport Plugin 1.4
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint unparam: true, nomen: true */
/*global define, window, document */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['jquery'], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // Helper variable to create unique names for the transport iframes:
    var counter = 0;

    // The iframe transport accepts three additional options:
    // options.fileInput: a jQuery collection of file input fields
    // options.paramName: the parameter name for the file form data,
    //  overrides the name property of the file input field(s),
    //  can be a string or an array of strings.
    // options.formData: an array of objects with name and value properties,
    //  equivalent to the return data of .serializeArray(), e.g.:
    //  [{name: 'a', value: 1}, {name: 'b', value: 2}]
    $.ajaxTransport('iframe', function (options) {
        if (options.async && (options.type === 'POST' || options.type === 'GET')) {
            var form,
                iframe;
            return {
                send: function (_, completeCallback) {
                    form = $('<form style="display:none;"></form>');
                    // javascript:false as initial iframe src
                    // prevents warning popups on HTTPS in IE6.
                    // IE versions below IE8 cannot set the name property of
                    // elements that have already been added to the DOM,
                    // so we set the name along with the iframe HTML markup:
                    iframe = $(
                        '<iframe src="javascript:false;" name="iframe-transport-' +
                            (counter += 1) + '"></iframe>'
                    ).bind('load', function () {
                        var fileInputClones,
                            paramNames = $.isArray(options.paramName) ?
                                    options.paramName : [options.paramName];
                        iframe
                            .unbind('load')
                            .bind('load', function () {
                                var response;
                                // Wrap in a try/catch block to catch exceptions thrown
                                // when trying to access cross-domain iframe contents:
                                try {
                                    response = iframe.contents();
                                    // Google Chrome and Firefox do not throw an
                                    // exception when calling iframe.contents() on
                                    // cross-domain requests, so we unify the response:
                                    if (!response.length || !response[0].firstChild) {
                                        throw new Error();
                                    }
                                } catch (e) {
                                    response = undefined;
                                }
                                // The complete callback returns the
                                // iframe content document as response object:
                                completeCallback(
                                    200,
                                    'success',
                                    {'iframe': response}
                                );
                                // Fix for IE endless progress bar activity bug
                                // (happens on form submits to iframe targets):
                                $('<iframe src="javascript:false;"></iframe>')
                                    .appendTo(form);
                                form.remove();
                            });
                        form
                            .prop('target', iframe.prop('name'))
                            .prop('action', options.url)
                            .prop('method', options.type);
                        if (options.formData) {
                            $.each(options.formData, function (index, field) {
                                $('<input type="hidden"/>')
                                    .prop('name', field.name)
                                    .val(field.value)
                                    .appendTo(form);
                            });
                        }
                        if (options.fileInput && options.fileInput.length &&
                                options.type === 'POST') {
                            fileInputClones = options.fileInput.clone();
                            // Insert a clone for each file input field:
                            options.fileInput.after(function (index) {
                                return fileInputClones[index];
                            });
                            if (options.paramName) {
                                options.fileInput.each(function (index) {
                                    $(this).prop(
                                        'name',
                                        paramNames[index] || options.paramName
                                    );
                                });
                            }
                            // Appending the file input fields to the hidden form
                            // removes them from their original location:
                            form
                                .append(options.fileInput)
                                .prop('enctype', 'multipart/form-data')
                                // enctype must be set as encoding for IE:
                                .prop('encoding', 'multipart/form-data');
                        }
                        form.submit();
                        // Insert the file input fields at their original location
                        // by replacing the clones with the originals:
                        if (fileInputClones && fileInputClones.length) {
                            options.fileInput.each(function (index, input) {
                                var clone = $(fileInputClones[index]);
                                $(input).prop('name', clone.prop('name'));
                                clone.replaceWith(input);
                            });
                        }
                    });
                    form.append(iframe).appendTo(document.body);
                },
                abort: function () {
                    if (iframe) {
                        // javascript:false as iframe src aborts the request
                        // and prevents warning popups on HTTPS in IE6.
                        // concat is used to avoid the "Script URL" JSLint error:
                        iframe
                            .unbind('load')
                            .prop('src', 'javascript'.concat(':false;'));
                    }
                    if (form) {
                        form.remove();
                    }
                }
            };
        }
    });

    // The iframe transport returns the iframe content document as response.
    // The following adds converters from iframe to text, json, html, and script:
    $.ajaxSetup({
        converters: {
            'iframe text': function (iframe) {
                return $(iframe[0].body).text();
            },
            'iframe json': function (iframe) {
                return $.parseJSON($(iframe[0].body).text());
            },
            'iframe html': function (iframe) {
                return $(iframe[0].body).html();
            },
            'iframe script': function (iframe) {
                return $.globalEval($(iframe[0].body).text());
            }
        }
    });

}));
